package com.syeedode.javaconcurrencyinpractice.exploitingparallelisms.travel;

import java.util.*;
import java.util.concurrent.*;

/**
 * Author: syeedode
 * Date: 4/2/18
 */
public class TravelQuoteService {
    private static final int NTHREADS = 100;
    private final ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);

    public List<TravelQuote> getRankedTravelQuotes(TravelInfo travelInfo
                                                , Set<TravelCompany> companies
                                                , Comparator<TravelQuote> ranking
                                                , long time
                                                , TimeUnit unit) throws InterruptedException {

        List<QuoteTask> tasks = new ArrayList<QuoteTask>();

        companies.stream().map(company -> tasks.add(new QuoteTask(company, travelInfo)));

        // The invokeAll method takes a collection of tasks
        // and returns a collection of Futures.
        //      The two collections have identical structures
        // The invokeAll method:
        //      1) adds the Futures to the returned collection in the order imposed by the task collectionâ€™s iterator
        //      2) this allows the caller to associate a 'Future' with the 'Callable' it represents
        //      3) (timed version) will return when
        //          a) all the tasks have completed
        //          b) the calling thread is interrupted
        //          c) the timeout expires
        //      4) any tasks that are not complete when the timeout expires are cancelled
        //
        // On return from invokeAll, each task will have either completed normally or been cancelled;
        // the client code can call get or isCancelled to find
        List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);

        List<TravelQuote> quotes = new ArrayList<TravelQuote>(tasks.size());

        Iterator<QuoteTask> taskIter = tasks.iterator();

        for (Future<TravelQuote> f : futures) {
            QuoteTask task = taskIter.next();
            try {
                quotes.add(f.get());
            } catch (ExecutionException e) {
                quotes.add(task.getFailureQuote(e.getCause()));
            } catch (CancellationException e) {
                quotes.add(task.getTimeoutQuote(e));
            }
        }
        Collections.sort(quotes, ranking);
        return quotes;
    }
}
