package com.syeedode.javaconcurrencyinpractice.exploitingparallelisms;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;

import static com.syeedode.javaconcurrencyinpractice.exploitingparallelisms.Ad.DEFAULT_AD;
import static java.util.concurrent.TimeUnit.NANOSECONDS;

/**
 * Author: syeedode
 * Date: 4/2/18
 */
public class Renderer {
    private static final long TIME_BUDGET = 100000;
    private final ExecutorService executor;

    Renderer(ExecutorService executor) { this.executor = executor; }

    void renderPage(CharSequence source) {
        List<ImageInfo> info = scanForImageInfo(source);
        CompletionService<ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);

        for (final ImageInfo imageInfo : info) {
            // Separate task to download each image <--> improves runtime
            // was
            // new Callable<ImageData>() {
            //  public ImageData call() {
            //      return imageInfo.downloadImage();
            //  }
            // }
            completionService.submit( () -> imageInfo.downloadImage() );
        }

        renderText(source);

        try {
            for (int t = 0, n = info.size(); t < n; t++) {
                // Fetching results from the CompletionService and rendering each image as soon as it is available.
                Future<ImageData> f = completionService.take();
                ImageData imageData = f.get();
                renderImage(imageData);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }

    /**
     * renderPageWithAd
     *
     * It generates a composite web page that contains the requested content
     * plus an advertisement fetched from an ad server.
     *      1) It submits the ad-fetching task to an executor
     *      2) Computes the rest of the page content, and then waits for the
     *         ad until its time budget runs out.
     *              The timeout passed to get is computed by subtracting the
     *              current time from the deadline; this may in fact yield a
     *              negative number, but all the timed methods in
     *              java.util.concurrent treat negative timeouts as zero, so
     *              no extra code is needed to deal with this case.
     *      3) If the 'get()' times out, it cancels the ad-fetching task and uses
     *         a default advertisement instead.
     *              The 'true' parameter to 'Future.cancel' means that the
     *              task thread can be interrupted if the task is currently
     *              running; see Chapter 7
     *
     * @param source
     * @return
     * @throws InterruptedException
     */
    Page renderPageWithAd(CharSequence source) throws InterruptedException {
        // Create the deadline for
        long endNanos = System.nanoTime() + TIME_BUDGET;

        // This is the advertisement fetched from an ad server.
        // Submitting the ad-fetching task to an executor
        Future<Ad> f = executor.submit(new FetchAdTask());

        // Render the page while waiting for the ad
        // Computing the rest of the page content
        Page page = renderPageBody();
        Ad ad;
        try {
            // Only wait for the remaining time budget
            // The timeout passed to 'get' is computed by subtracting the
            //      current time from the deadline
            //
            long timeLeft = endNanos - System.nanoTime();

            ad = f.get(timeLeft, NANOSECONDS);
        } catch (ExecutionException e) {
            ad = DEFAULT_AD;
        } catch (TimeoutException e) {
            // If the 'get()' times out, it cancels the ad-fetching task
            //      and uses a default advertisement instead.
            ad = DEFAULT_AD;
            f.cancel(true);
        }
        page.setAd(ad);
        return page;
    }

    private Page renderPageBody() {
        return null;
    }

    private void renderText(CharSequence source) {

    }

    private void renderImage(ImageData data) {

    }

    private List<ImageInfo> scanForImageInfo(CharSequence source) {
        return Arrays.asList(new ImageInfo[0]);
    }

    private RuntimeException launderThrowable(Throwable cause) {
        return new RuntimeException(cause);
    }
}